"""Comprehensive event management interface with filtering, actions, and analytics."""

import streamlit as st
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
import pandas as pd
from collections import defaultdict

from src.storage import SQLiteStorage
from src.models.event_dto import EventDTO


# Event type icons and colors
EVENT_TYPE_CONFIG = {
    "funding": {"icon": "ğŸ’°", "color": "#10b981", "label": "Funding"},
    "acquisition": {"icon": "ğŸ¤", "color": "#3b82f6", "label": "Acquisition"},
    "leadership": {"icon": "ğŸ‘”", "color": "#8b5cf6", "label": "Leadership"},
    "product": {"icon": "ğŸš€", "color": "#f59e0b", "label": "Product"},
    "partnership": {"icon": "ğŸ”—", "color": "#06b6d4", "label": "Partnership"},
    "financial": {"icon": "ğŸ“Š", "color": "#14b8a6", "label": "Financial"},
    "award": {"icon": "ğŸ†", "color": "#fbbf24", "label": "Award"},
    "regulatory": {"icon": "âš–ï¸", "color": "#ef4444", "label": "Regulatory"},
    "news": {"icon": "ğŸ“°", "color": "#6366f1", "label": "News"},
    "other": {"icon": "ğŸ“Œ", "color": "#6b7280", "label": "Other"},
}

SENTIMENT_CONFIG = {
    "positive": {"emoji": "ğŸ˜Š", "color": "#10b981"},
    "neutral": {"emoji": "ğŸ˜", "color": "#6b7280"},
    "negative": {"emoji": "ğŸ˜Ÿ", "color": "#ef4444"},
}


def render_filters_sidebar(storage: SQLiteStorage) -> Dict[str, Any]:
    """
    Render filters in sidebar and return filter values.

    Args:
        storage: Storage instance

    Returns:
        Dictionary of filter values
    """
    st.sidebar.markdown("### ğŸ” Filters")

    # Date range
    st.sidebar.markdown("**Date Range**")
    date_preset = st.sidebar.radio(
        "Quick select",
        ["Today", "Last 7 days", "Last 30 days", "Last 90 days", "All time"],
        index=1,
        label_visibility="collapsed"
    )

    if date_preset == "Today":
        from_date = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
    elif date_preset == "Last 7 days":
        from_date = datetime.utcnow() - timedelta(days=7)
    elif date_preset == "Last 30 days":
        from_date = datetime.utcnow() - timedelta(days=30)
    elif date_preset == "Last 90 days":
        from_date = datetime.utcnow() - timedelta(days=90)
    else:
        from_date = None

    st.sidebar.divider()

    # Client filter
    all_clients = storage.get_all_clients()
    client_options = ["All Clients"] + [c.name for c in all_clients]
    selected_clients = st.sidebar.multiselect(
        "ğŸ“Š Clients",
        options=client_options,
        default=["All Clients"]
    )

    # Event type filter
    event_type_labels = [f"{config['icon']} {config['label']}"
                         for config in EVENT_TYPE_CONFIG.values()]
    selected_event_types = st.sidebar.multiselect(
        "ğŸ·ï¸ Event Types",
        options=["All Types"] + event_type_labels,
        default=["All Types"]
    )

    # Sentiment filter
    sentiment_options = [f"{config['emoji']} {sentiment.capitalize()}"
                        for sentiment, config in SENTIMENT_CONFIG.items()]
    selected_sentiments = st.sidebar.multiselect(
        "ğŸ˜Š Sentiment",
        options=["All Sentiments"] + sentiment_options,
        default=["All Sentiments"]
    )

    # Status filter
    status_options = ["New", "Reviewed", "Actioned", "Archived"]
    selected_statuses = st.sidebar.multiselect(
        "ğŸ“‹ Status",
        options=["All Statuses"] + status_options,
        default=["All Statuses"]
    )

    # Relevance score
    st.sidebar.markdown("**Relevance Score**")
    min_relevance = st.sidebar.slider(
        "Minimum relevance",
        min_value=0.0,
        max_value=1.0,
        value=0.0,
        step=0.1,
        label_visibility="collapsed"
    )

    st.sidebar.divider()

    # Action buttons
    col1, col2 = st.sidebar.columns(2)
    with col1:
        if st.button("âœ… Apply", use_container_width=True, type="primary"):
            st.rerun()
    with col2:
        if st.button("ğŸ”„ Clear", use_container_width=True):
            st.session_state.clear()
            st.rerun()

    return {
        "from_date": from_date,
        "selected_clients": selected_clients,
        "selected_event_types": selected_event_types,
        "selected_sentiments": selected_sentiments,
        "selected_statuses": selected_statuses,
        "min_relevance": min_relevance,
    }


def apply_filters(events: List[EventDTO], filters: Dict[str, Any], storage: SQLiteStorage) -> List[EventDTO]:
    """Apply filters to events list."""
    filtered = events.copy()

    # Date filter
    if filters["from_date"]:
        filtered = [e for e in filtered if e.discovered_date >= filters["from_date"]]

    # Client filter
    if "All Clients" not in filters["selected_clients"] and filters["selected_clients"]:
        client_ids = []
        for client_name in filters["selected_clients"]:
            clients = [c for c in storage.get_all_clients() if c.name == client_name]
            if clients:
                client_ids.append(clients[0].id)
        filtered = [e for e in filtered if e.client_id in client_ids]

    # Event type filter
    if "All Types" not in filters["selected_event_types"] and filters["selected_event_types"]:
        # Extract event types from labels (e.g., "ğŸ’° Funding" -> "funding")
        selected_types = []
        for label in filters["selected_event_types"]:
            for event_type, config in EVENT_TYPE_CONFIG.items():
                if config["label"] in label:
                    selected_types.append(event_type)
        filtered = [e for e in filtered if e.event_type in selected_types]

    # Sentiment filter
    if "All Sentiments" not in filters["selected_sentiments"] and filters["selected_sentiments"]:
        selected_sentiments = []
        for label in filters["selected_sentiments"]:
            for sentiment in SENTIMENT_CONFIG.keys():
                if sentiment.capitalize() in label:
                    selected_sentiments.append(sentiment)
        filtered = [e for e in filtered if e.sentiment in selected_sentiments]

    # Status filter
    if "All Statuses" not in filters["selected_statuses"] and filters["selected_statuses"]:
        status_map = {"New": "new", "Reviewed": "reviewed", "Actioned": "actioned", "Archived": "archived"}
        selected_statuses = [status_map[s] for s in filters["selected_statuses"]]
        filtered = [e for e in filtered if e.status in selected_statuses]

    # Relevance filter
    filtered = [e for e in filtered if e.relevance_score >= filters["min_relevance"]]

    return filtered


def render_event_card(event: EventDTO, client_name: str, storage: SQLiteStorage, expanded: bool = False):
    """Render a single event card."""
    config = EVENT_TYPE_CONFIG.get(event.event_type, EVENT_TYPE_CONFIG["other"])
    sentiment_config = SENTIMENT_CONFIG.get(event.sentiment, SENTIMENT_CONFIG["neutral"])

    # Relevance color
    if event.relevance_score >= 0.7:
        relevance_color = "#10b981"
    elif event.relevance_score >= 0.4:
        relevance_color = "#f59e0b"
    else:
        relevance_color = "#6b7280"

    with st.container(border=True):
        # Header row
        col1, col2, col3 = st.columns([3, 1, 1])

        with col1:
            st.markdown(f"**{client_name}** Â· {config['icon']} {config['label']}")

        with col2:
            days_ago = (datetime.utcnow() - event.published_date).days
            if days_ago == 0:
                date_str = "Today"
            elif days_ago == 1:
                date_str = "Yesterday"
            else:
                date_str = f"{days_ago}d ago"
            st.caption(date_str)

        with col3:
            st.markdown(f"""
            <div style="text-align: right;">
                <span style="background-color: {relevance_color}; color: white;
                             padding: 2px 8px; border-radius: 10px; font-size: 0.75em;">
                    {event.relevance_score:.2f}
                </span>
            </div>
            """, unsafe_allow_html=True)

        # Title
        if event.source_url:
            st.markdown(f"### [{event.title}]({event.source_url})")
        else:
            st.markdown(f"### {event.title}")

        # Summary (expandable)
        if event.summary:
            with st.expander("ğŸ“„ Summary", expanded=expanded):
                st.write(event.summary)

        # Metadata row
        col1, col2, col3 = st.columns(3)

        with col1:
            st.write(f"{sentiment_config['emoji']} {event.sentiment.capitalize()}")

        with col2:
            if event.source_name:
                st.write(f"ğŸ“° {event.source_name}")

        with col3:
            status_icons = {"new": "ğŸ†•", "reviewed": "ğŸ‘ï¸", "actioned": "âœ…", "archived": "ğŸ“¦"}
            st.write(f"{status_icons.get(event.status, 'ğŸ“Œ')} {event.status.capitalize()}")

        # Tags
        if event.tags:
            st.markdown(" ".join([f"`{tag}`" for tag in event.tags]))

        st.divider()

        # Actions
        col1, col2, col3, col4, col5 = st.columns(5)

        with col1:
            if event.status != "reviewed" and st.button("ğŸ‘ï¸ Reviewed", key=f"review_{event.id}", use_container_width=True):
                event.mark_as_reviewed()
                storage.update_event(event.id, {"status": "reviewed"})
                st.rerun()

        with col2:
            if event.status != "actioned" and st.button("âœ… Actioned", key=f"action_{event.id}", use_container_width=True):
                event.mark_as_actioned()
                storage.update_event(event.id, {"status": "actioned"})
                st.rerun()

        with col3:
            if event.status != "archived" and st.button("ğŸ“¦ Archive", key=f"archive_{event.id}", use_container_width=True):
                event.archive()
                storage.update_event(event.id, {"status": "archived"})
                st.rerun()

        with col4:
            if st.button("ğŸ—‘ï¸ Delete", key=f"delete_{event.id}", use_container_width=True):
                st.session_state[f"deleting_event_{event.id}"] = True
                st.rerun()

        # Delete confirmation
        if st.session_state.get(f"deleting_event_{event.id}", False):
            st.warning("âš ï¸ Delete this event?")
            col1, col2 = st.columns(2)
            with col1:
                if st.button("âœ… Yes", key=f"confirm_delete_{event.id}", type="primary"):
                    storage.delete_event(event.id)
                    del st.session_state[f"deleting_event_{event.id}"]
                    st.rerun()
            with col2:
                if st.button("âŒ No", key=f"cancel_delete_{event.id}"):
                    del st.session_state[f"deleting_event_{event.id}"]
                    st.rerun()

        # Notes section
        with st.expander("ğŸ“ Notes"):
            notes = st.text_area(
                "Add notes",
                value=event.user_notes or "",
                key=f"notes_{event.id}",
                height=100,
                label_visibility="collapsed"
            )
            if st.button("ğŸ’¾ Save Notes", key=f"save_notes_{event.id}"):
                storage.update_event(event.id, {"user_notes": notes})
                st.success("Notes saved!")
                st.rerun()


def render_list_view(events: List[EventDTO], storage: SQLiteStorage):
    """Render events in list view."""
    if not events:
        st.info("ğŸ“­ No events found matching your filters")
        return

    # Sort options
    col1, col2 = st.columns([3, 1])
    with col2:
        sort_by = st.selectbox(
            "Sort by",
            ["Relevance (High to Low)", "Date (Newest First)", "Date (Oldest First)", "Client Name"],
            label_visibility="collapsed"
        )

    # Sort events
    if sort_by == "Relevance (High to Low)":
        events_sorted = sorted(events, key=lambda e: e.relevance_score, reverse=True)
    elif sort_by == "Date (Newest First)":
        events_sorted = sorted(events, key=lambda e: e.published_date, reverse=True)
    elif sort_by == "Date (Oldest First)":
        events_sorted = sorted(events, key=lambda e: e.published_date)
    else:  # Client Name
        events_sorted = sorted(events, key=lambda e: storage.get_client(e.client_id).name if storage.get_client(e.client_id) else "")

    # Pagination
    items_per_page = 10
    total_pages = (len(events_sorted) + items_per_page - 1) // items_per_page

    if "events_page" not in st.session_state:
        st.session_state.events_page = 1

    start_idx = (st.session_state.events_page - 1) * items_per_page
    end_idx = min(start_idx + items_per_page, len(events_sorted))

    # Render events
    for event in events_sorted[start_idx:end_idx]:
        client = storage.get_client(event.client_id)
        client_name = client.name if client else "Unknown Client"
        render_event_card(event, client_name, storage)

    # Pagination controls
    if total_pages > 1:
        st.divider()
        col1, col2, col3 = st.columns([1, 2, 1])

        with col1:
            if st.button("â—€ Previous", disabled=st.session_state.events_page == 1):
                st.session_state.events_page -= 1
                st.rerun()

        with col2:
            st.markdown(f"<div style='text-align: center;'>Page {st.session_state.events_page} of {total_pages}</div>",
                       unsafe_allow_html=True)

        with col3:
            if st.button("Next â–¶", disabled=st.session_state.events_page == total_pages):
                st.session_state.events_page += 1
                st.rerun()


def render_timeline_view(events: List[EventDTO], storage: SQLiteStorage):
    """Render events in timeline view."""
    if not events:
        st.info("ğŸ“­ No events found matching your filters")
        return

    # Group by date
    events_by_date = defaultdict(list)
    for event in sorted(events, key=lambda e: e.published_date, reverse=True):
        date_key = event.published_date.strftime("%Y-%m-%d")
        events_by_date[date_key].append(event)

    # Render timeline
    for date_str, date_events in events_by_date.items():
        date_obj = datetime.strptime(date_str, "%Y-%m-%d")
        days_ago = (datetime.utcnow() - date_obj).days

        if days_ago == 0:
            date_label = "Today"
        elif days_ago == 1:
            date_label = "Yesterday"
        else:
            date_label = date_obj.strftime("%B %d, %Y")

        st.markdown(f"### ğŸ“… {date_label}")
        st.caption(f"{len(date_events)} event(s)")

        for event in date_events:
            client = storage.get_client(event.client_id)
            client_name = client.name if client else "Unknown Client"

            config = EVENT_TYPE_CONFIG.get(event.event_type, EVENT_TYPE_CONFIG["other"])

            with st.expander(f"{config['icon']} **{client_name}** - {event.title}"):
                render_event_card(event, client_name, storage, expanded=True)

        st.divider()


def render_table_view(events: List[EventDTO], storage: SQLiteStorage):
    """Render events in table view."""
    if not events:
        st.info("ğŸ“­ No events found matching your filters")
        return

    # Prepare data
    data = []
    for event in events:
        client = storage.get_client(event.client_id)
        client_name = client.name if client else "Unknown"

        config = EVENT_TYPE_CONFIG.get(event.event_type, EVENT_TYPE_CONFIG["other"])

        data.append({
            "Client": client_name,
            "Title": event.title[:60] + "..." if len(event.title) > 60 else event.title,
            "Type": f"{config['icon']} {config['label']}",
            "Date": event.published_date.strftime("%Y-%m-%d"),
            "Relevance": f"{event.relevance_score:.2f}",
            "Sentiment": event.sentiment.capitalize(),
            "Status": event.status.capitalize(),
            "Source": event.source_name or "â€”",
        })

    df = pd.DataFrame(data)

    # Display table
    st.dataframe(
        df,
        use_container_width=True,
        hide_index=True,
        column_config={
            "Relevance": st.column_config.ProgressColumn(
                "Relevance",
                min_value=0.0,
                max_value=1.0,
            ),
        }
    )

    # Export button
    if st.button("ğŸ“¥ Export to CSV"):
        csv = df.to_csv(index=False)
        st.download_button(
            label="Download CSV",
            data=csv,
            file_name=f"events_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv"
        )


def render_analytics_view(events: List[EventDTO], storage: SQLiteStorage):
    """Render analytics and charts."""
    if not events:
        st.info("ğŸ“­ No events found matching your filters")
        return

    # Summary metrics
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric("Total Events", len(events))

    with col2:
        avg_relevance = sum(e.relevance_score for e in events) / len(events)
        st.metric("Avg Relevance", f"{avg_relevance:.2f}")

    with col3:
        new_count = len([e for e in events if e.status == "new"])
        st.metric("New Events", new_count)

    with col4:
        unique_clients = len(set(e.client_id for e in events))
        st.metric("Clients", unique_clients)

    st.divider()

    # Charts
    col1, col2 = st.columns(2)

    with col1:
        st.subheader("ğŸ“Š Events by Type")
        type_counts = defaultdict(int)
        for event in events:
            type_counts[event.event_type] += 1

        type_data = pd.DataFrame([
            {"Type": EVENT_TYPE_CONFIG.get(t, EVENT_TYPE_CONFIG["other"])["label"], "Count": c}
            for t, c in type_counts.items()
        ])
        st.bar_chart(type_data.set_index("Type"))

    with col2:
        st.subheader("ğŸ˜Š Sentiment Distribution")
        sentiment_counts = defaultdict(int)
        for event in events:
            sentiment_counts[event.sentiment] += 1

        sentiment_data = pd.DataFrame([
            {"Sentiment": s.capitalize(), "Count": c}
            for s, c in sentiment_counts.items()
        ])
        st.bar_chart(sentiment_data.set_index("Sentiment"))

    st.divider()

    col1, col2 = st.columns(2)

    with col1:
        st.subheader("ğŸ† Top Clients by Events")
        client_counts = defaultdict(int)
        for event in events:
            client = storage.get_client(event.client_id)
            if client:
                client_counts[client.name] += 1

        top_clients = sorted(client_counts.items(), key=lambda x: x[1], reverse=True)[:10]
        client_data = pd.DataFrame(top_clients, columns=["Client", "Events"])
        st.bar_chart(client_data.set_index("Client"))

    with col2:
        st.subheader("ğŸ“° Top Sources")
        source_counts = defaultdict(int)
        for event in events:
            if event.source_name:
                source_counts[event.source_name] += 1

        top_sources = sorted(source_counts.items(), key=lambda x: x[1], reverse=True)[:10]
        if top_sources:
            source_data = pd.DataFrame(top_sources, columns=["Source", "Events"])
            st.bar_chart(source_data.set_index("Source"))
        else:
            st.info("No source data available")

    st.divider()

    # Relevance distribution
    st.subheader("ğŸ“ˆ Relevance Score Distribution")
    relevance_buckets = {"0.0-0.3": 0, "0.3-0.5": 0, "0.5-0.7": 0, "0.7-1.0": 0}
    for event in events:
        if event.relevance_score < 0.3:
            relevance_buckets["0.0-0.3"] += 1
        elif event.relevance_score < 0.5:
            relevance_buckets["0.3-0.5"] += 1
        elif event.relevance_score < 0.7:
            relevance_buckets["0.5-0.7"] += 1
        else:
            relevance_buckets["0.7-1.0"] += 1

    relevance_data = pd.DataFrame([
        {"Range": k, "Count": v}
        for k, v in relevance_buckets.items()
    ])
    st.bar_chart(relevance_data.set_index("Range"))


def render_events_page():
    """Main events page with multiple views."""
    st.markdown('<h1 class="main-header">Event Management</h1>', unsafe_allow_html=True)
    st.markdown('<p class="subtitle">Browse, filter, and manage events across all clients</p>', unsafe_allow_html=True)

    # Initialize storage
    storage = SQLiteStorage()
    storage.connect()

    # Render filters in sidebar
    filters = render_filters_sidebar(storage)

    # Get all events
    all_events = storage.get_all_events()

    # Apply filters
    filtered_events = apply_filters(all_events, filters, storage)

    # View selector
    st.divider()

    view_mode = st.radio(
        "View Mode",
        ["ğŸ“‹ List", "ğŸ“… Timeline", "ğŸ“Š Table", "ğŸ“ˆ Analytics"],
        horizontal=True,
        label_visibility="collapsed"
    )

    st.markdown(f"**{len(filtered_events)}** events found")
    st.divider()

    # Render selected view
    if view_mode == "ğŸ“‹ List":
        render_list_view(filtered_events, storage)
    elif view_mode == "ğŸ“… Timeline":
        render_timeline_view(filtered_events, storage)
    elif view_mode == "ğŸ“Š Table":
        render_table_view(filtered_events, storage)
    else:  # Analytics
        render_analytics_view(filtered_events, storage)
